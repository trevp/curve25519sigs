
Curve25519 Signatures
######################

.. sectnum::

:Author: Trevor Perrin
:Contact: curves@trevp.net
:Date: 2014-09-29
:Status: Work in progress
:Version: 0
:Revision: 0
:Copyright: This document is hereby placed in the public domain

.. contents::

Introduction
=============
This document describes the use of Curve25519 keypairs for creating
and verifying Ed25519 signatures ([Curve25519]_, [Ed25519]_).  This
could be used in systems where:

1.  You'd like to deal with signature and ECDH public keys using a single format.
2.  You'd like to distribute a single public key and use it for both signatures and ECDH.

Case 2 goes against the traditional practice of using a single 
keypair with only a single algorithm (i.e. ECDH *or* signatures).  While
that practice is prudent, this reuse of elliptic curve keypairs is believed to be secure if
certain conditions are met [ModernCrypto]_.

Algorithms
===========

Variables
----------

======= =============================================== ============
Name    Explanation                                     Size (bytes)
======= =============================================== ============
a       Private scalar                                  32
A       Curve25519 public key                           32
A_ed    Ed25519 conversion of Curve25519 public key     32
B       Ed25519 base point                              -
random  Random value from secure RNG                    64
label   ``[0xFE] || [0xFF]*31`` (for random oracles)    32
msg     Message to be signed                            any
L       Order of base point                             -
======= =============================================== ============

Key generation
---------------
The private scalar is a typical Curve25519 or Ed25519 private key,
which can be generated by following the advice in [Curve25519]_: "generate 32
uniform random bytes, clear bits 0, 1, 2 of the first byte, clear bit 7 of the last
byte, and set bit 6 of the last byte."

Signing
--------
::

 Sign(a, msg, random):
   # Derive Schnorr nonce
   r = SHA512(label || a || msg || random)  (mod L)

   # Calculate Ed25519 public key
   A_ed = a * B

   # Create standard Ed25519 signature
   R = r * B
   S = r + SHA512(R || A_ed || msg) * a  (mod L)
   signature = R || S

   # Copy sign bit of public key into unused bit of signature:
   signature[63] |= A_ed[31] & 0x80
   return signature

Verifying
----------
::

 Verify(A, msg, signature):
   # Convert Curve25519 public key to Ed25519 form
   A_ed = (A-1) * ((A+1)^-1)  (mod 2^255-19)

   # Move sign bit from signature to public key
   A_ed[31] |= (signature[63] & 0x80);
   signature[63] &= 0x7F

   # Verify standard Ed25519 signature
   return Ed25519_Verify(A_ed, signature, msg)


Implementation considerations
==============================

Key conversion
---------------
Converting the Curve25519 public key to Ed25519 is straightforward
using the equivalence ``y = (A-1)/(A+1)`` ([Ed25519]_, [TwistedEdwards]_).  ``A=-1`` should be mapped to 0, which happens naturally if inversion is done with exponentiation.

Performance
------------
**Signing:** Recalculating the Ed25519 public key on every signature
causes a (measured) slowdown of ~60% when signing small messages vs plain Ed25519.  It would be easy to store the public key and eliminate this slowdown.

**Verifying:** Converting the public key causes a (measured) slowdown of 6-7% vs plain Ed25519 for small messages.  This could be probably be optimized to "below 1%" by combining conversion with decompression ([CFRG]_).

Security considerations
========================

Sign bit
---------
The Ed25519 sign bit could be stored in the unused high bit of a
Curve25519 public key.  But for compatibility with existing Curve25519
keys it's here stored in the signature (an idea due to Robert Ransom).  This allows an attacker to try to forge a signature for Alice based on either her "real" Ed25519 public key or its negative.  But both are legitimate public keys, so an attacker who can't break Ed25519 can't forge signatures for either.

Nonce
------
The Ed25519 paper [Ed25519]_ recommends deriving the Schnorr nonce as::

  r = SHA512(nonce_key || msg)  (mod L)

Where both ``nonce_key`` and the private scalar are derived from a master key.  To sign with existing scalars we instead do::

  r = SHA512(label || a || msg || random)  (mod L)

The label is to aid security proofs in the Random Oracle Model (such as Pointcheval-Stern [PS]_) by separating uses of the hash function.

The random value is not essential but helps ensures the nonce and
scalar are independent, and reduces the risk of nonce collisions or
biases.

ECDH + signatures
------------------
We can now create Ed25519 signatures and perform certain ECDH-based key agreements using not just the same Curve25519 key format but the same keypair [ModernCrypto]_.

If using the same keypair for signatures and ECDH, the ECDH output should be hashed via a different "random oracle", e.g. SHA512 with a label prefix of ``[0xFF]*32``.

Acknowledgements
=================
Thanks to Robert Ransom, Mike Hamburg, Samuel Neves, Christian Winnerlein, and Watson Ladd for advice and feedback at different stages.


References
===========
.. [Curve25519] http://cr.yp.to/ecdh/curve25519-20060209.pdf
.. [Ed25519] http://ed25519.cr.yp.to/ed25519-20110926.pdf
.. [PS] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.8213
.. [TwistedEdwards] http://eprint.iacr.org/2008/013.pdf
.. [ModernCrypto] https://moderncrypto.org/mail-archive/curves/2014/000205.html
.. [CFRG] http://www.ietf.org/mail-archive/web/cfrg/current/msg04816.html
